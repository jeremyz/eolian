

Improve:
- when trying to add class name, which already in database, maybe should print
  which file is parsed right now.

To think about:
- virtual pure
- add name of data structure into eo file

- Can we have multiple constructors in Eo2?
  Do we need to write constructors in separate section ob JSON?
  in Py, C++, constructor has the same name. in Eo - not, what's in Eo2?

Fix in parsing
   (doesn't matter in JSON)
  - when splitting parameters, comma can be in comment!!!



  Thoughts about return type.

  First of all.
  I suggest to think, that generation of eo funcs is generation of lib.
  And generation of legacy is already generation of bindings. As generation of python or c++ bindings.

  For example: there are no legacy API for elm_app_***(maybe they are not ready yet). So in this case legacy really will be bindings!

  Now let's see several examples:

  Function is property if all of it's parameters are "in" for "set", and "out" for "get".
  If we have RW property
  "color"
   {
     "r" : [int],
     "b" : [int],
     "g" : [int],
     "a" : [int]
   }

In this case, bindings can look like this:

for C(legacy):
color_get(Eo *obj, int *r, int *g, int *b, int *a)
{
   eo_do(obj, _color_get(r, g, b, a));
}

for Python(as I did for bindings):
getter_of_color_property(self):
   cint _r, _g, _b, _a  #declarations of int vars which can be used in call of C-func from python
   eo_do(self.eo_obj, _color_get(&_r, &_g, &_b, &_a));
   r = _r
   g = _g
   b = _b
   a = _a
   return (r, g, b, a)

   Usage smth like this:
   (r, g, b, a) = button_object.color
   label_object.color = (r, g, b, a)

for C++: (imaging)
getter_of_color_property(CppEoClass *cpp_eo):
   int _r, _g, _b, _a
   eo_do(cpp_eo->c_eo_obj, _color_get(&_r, &_g, &_b, &_a));
   Vector v;
   v.append(_r)
   v.append(_b)
   v.append(_g)
   v.append(_a)
   return v

   Usage smth like this:
   color_vector = button_object.color

So "get_only" property works same.

I think there is no need(And I don't see how it will help) to mark any parameters as return.
If there are several parameters which are "out" they will be returned as a pointer.
If there is one parameter which is out, it will be returned from func as usual.

Now methods.
"view_open": {
     "comment": "Open a application view.", 
        "parameters": [
           [ "in", "", "Eina_Value*", "args", "an array of" ], 
           [ "in", "", "Elm_App_Client_Open_View_Cb", "view_open_cb", "callback to be called when view open" ], 
           [ "in", "const", "void*", "data", "calback user data" ], 
           [ "out", "", "Elm_App_Client_Pending*", "pending", "handler to cancel the view opening if it takes to long" ]
      ]
}, 

Everything generally the same.
If last parameter is "out" and it is the only "out" it will be returned as usual.
Question: what to do if there are more than one "out" parameter? (mark this with *)
More question: what to do with such method when generating python bindings.
But answer shuld be easy: just return it in Python style: (a, b) = obj.some_func(c, d)

Concerning *-ed question. In method like this:
    "file_get": {
      "comment": "Get the file being edited by the entry.", 
      "parameters": [
        [ "out", "const", "char*", "file", "" ], 
        [ "out", "", "Elm_Text_Format", "format", "" ]
      ]
    }, 

    which returns void in legacy, looks like we need to have some return.
    In c we have return type. But this is functions attribute, not parameter's.
    So let's add field {"return_last" : false} for method. (This is first solution)


I was takling to Cedric. He told that we can apply here any conventions we want.
Like "in" parameters are always in the beginning, "out" - in the end.
So we can tell, that parameter will be returned, if it is the only "out" parameter in function.
(This is second solution)

Second I like more.
(That's not about, that I don't want to mark some param as return.
 In each func return param named by it's own, not simply "ret", so anyway to make it automatically,
 I will have to parse legacy, to understand if func returns anything)

As I've shown, each languge has it's own return style.
So I think it's not completely clear how to describe return in eo file and easier to go with some conventions.

Waiting for your ideas. :)



